<!doctype html>
<html lang=ru id=faq>


<title>OpenBSD Порты: Отличие от других BSD проектов</title>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="../../openbsd.css">
<link rel="canonical" href="https://www.openbsd.org/faq/ports/differences.html">

<h2 id=OpenBSD>
<a href="../../index.html">
<i>Open</i><b>BSD</b></a>
Порты - Отличие от других BSD проектов
<small>
<a href="index.html">[Порты - На главную]</a>
</small>
</h2>
<hr>

<ul>
  <li><a href="#Extra"          >Дополнительная помощь</a>
  <li><a href="#Generic"        >Общие вопросы по поводу инфраструктуры</a>
  <li><a href="#Make"           >Используйте make правильно</a>
  <li><a href="#Fetch"          >Загрузка исходников</a>
  <li><a href="#wrkdir"         >Инфраструктура <code>WRKDIR</code></a>
  <li><a href="#Fake"           >Faking Ports</a>
    <ul>
     <li><a href="#Introduction">Введение</a>
     <li><a href="#Advantages"  >Преимущества</a>
     <li><a href="#How"         >Как это использовать</a>
     <li><a href="#Pitfalls"    >Ловушки</a>
    </ul>
  <li><a href="#Tools"          >Packaging инструменты</a>
  <li><a href="#Flavors"        >Flavors</a>
</ul>

<hr>

<h2 id="Extra">Дополнительная помощь</h2>

Инфраструктура портирования включает в себя несколько скриптов, которые
находятся в <code>infrastructure/bin</code>. Они предназначены для упрощения
процесса создания новых портов:

<dl>
<dt>check-lib-depends
    <dd>Запускается при помощи <code>make lib-depends-check</code> с целью
    проверки shared libraries зависимостей.
<dt>update-patches
    <dd>Запускается при помощи <code>make update-patches</code>, который
    <b>всегда</b> должен использоваться для обновления/регенерации патчей.
<dt>update-plist
    <dd>Запускается при помощи <code>make update-plist</code>.
    Этот скрипт позаботится о аккуратности packing-lists. OpenBSD packing-lists
    значительно отличаются от своих сородичей из других проектов BSD, отчасти
    потому, что packaging инструменты в ней были полностью переписаны.
</dl>

Проверьте каталог <code>infrastructure/bin</code>, если вы ищете другие полезные
скрипты. Для большинства из них есть man-страницы.

<h2 id="Generic">Общие вопросы по поводу инфраструктуры</h2>

<a href="https://man.openbsd.org/make">make(1)</a> в OpenBSD поддерживает
<code>${VAR:U}</code> и <code>${VAR:L}</code> для преобразования значения
переменной в верхний или нижний регистр. Другими словами, make test может
быть запущен независимо от регистра. Например:

<pre class="cmdbox">
.if ${NEED_XXX:L} == "yes"
do stuff if yes
.else
do other stuff
.endif
</pre>

Теоретически, все bool-переменные, распознаваемые <code>bsd.port.mk</code>,
всегда должны быть определены, поэтому в констукциях кода наподобее
<code>defined(USE_FOO)</code> нет необходимости, и
<code>${USE_FOO:L} != "no"</code> должен работать.

<p>
Основной файл <code>bsd.port.mk</code> был сильно оптимизирован и исправлен.
В частности, он может выполнять задачи параллельно.
Из-за этого была утрачена функция <code>scripts/{pre,do,post}-*</code>.
Чтобы снова воспользоваться этой функцией, запустите скрипт вручную из
<code>Makefile</code>.

<h2 id="Make">Используйте make правильно</h2>

Обратите внимание, что если вы запускаете make с параметром (например вот так
<code><b>make VAR=value</b></code>), присваиваемое значение параметра
переопределяет/перезаписывает значение, которое присваивается <code>VAR</code>
из <code>Makefile</code>.
Это означает, что нет необходимости в множестве патчей для <code>Makefile</code>.
Гораздо лучше правильно установить значение <code>MAKE_FLAGS</code>,
что к тому же снизит и maintanance нагрузку.

<h2 id="Fetch">Загрузка исходников</h2>

Существует два типа архивов с исходниками: <code>DISTFILES</code> и
<code>PATCHFILES</code>.
OpenBSD обрабатывает их одинаковым способом и по умолчанию загружает все
из <code>MASTER_SITES</code>. Здесь <b>нет</b> ни <code>PATCH_SITES</code>,
ни <code>PATCH_SITES_SUBDIR</code>.

<p>
Если все загружаемые файлы не принадлежат одному и тому же набору сайтов,
OpenBSD разрешает расширение <code>filename:0</code> до <code>filename:9</code>,
и в этом случае для извлечения файлов будет использоваться
<code>MASTER_SITES0</code> вплоть до <code>MASTER_SITES9</code>.

<p>
Некоторым платформам могут понадобиться специфичные distfiles.
В прошлом это вызывало проблемы, связанные с зеркалированием distfiles.
Теперь же OpenBSD поддерживает третий набор файлов: <code>SUPDISTFILES</code>.
Они используются только для создания checksums и для зеркалирования
(mirroring). Обратите внимание, что <code>SUPDISTFILES</code> может
перекрываться <code>DISTFILES</code> или <code>PATCHFILES</code>.
Например:

<pre class="cmdbox">
DISTFILES=foo-1.0.tgz
.if ${ARCH} == "i386"
DISTFILES+=foo-i386.tgz
.elif ${ARCHI} == "amd64"
DISTFILES+=foo-amd64.tgz
.endif
SUPDISTFILES=foo-i386.tgz foo-amd64.tgz
</pre>

<h2 id="wrkdir">Инфраструктура <code>WRKDIR</code></h2>

Нам не нужны порты, которые используют <code>NO_WRKDIR</code>.
Все порты OpenBSD должны иметь рабочий каталог.
Детали, касательно имени каталога не должно вызывать беспокойства
у того, кто собирает порт. Если вам нужно узнать об этом имени,
спросите <code>Makefile</code>:

<pre class="cmdbox">
$ <b>cd that_ports_dir &amp;&amp; make show=WRKDIR</b>
</pre>

Эта команда покажет значение <code>WRKDIR</code> (т.е. имя рабочего
каталога) порта.

<p>
Основная причина этого запрета заключается в том, что <code>bsd.port.mk</code>
в OpenBSD действует как настоящий <code>Makefile</code> с зависимостями.
Этап <code>fetch</code> зависит от distfiles и patchfiles,, а все остальные
этапы зависят от реальных файлов, находящихся в рабочем каталоге, поэтому
они не могут существовать без рабочего каталога.

<p>
Если <code>DISTFILES</code> extraction является особенным, установите

<pre class="cmdbox">
EXTRACT_ONLY=
</pre>

и сделайте extraction на этапе <code>post-extract.</code>.

<p>
<dl>
<dt><code>WRKDIR</code></dt>

<dd>The port working directory, where it puts its own cookies.</dd>

<dt><code>WRKDIST</code></dt>

<dd>Subdirectory of <code>WRKDIR</code> where the port actually unpacks.
It is also the base directory for patch.
Other BSDs currently don't have the <code>WRKDIST/WRKSRC</code> distinction and
have only <code>WRKSRC</code>.</dd>

<dt><code>WRKSRC</code></dt>

<dd>Subdirectory of <code>WRKDIST</code> where the actual source lives.</dd>

<dt><code>WRKBUILD</code></dt>

<dd>Subdirectory of <code>WRKDIR</code> where the port configure and build will
occur.
Other BSDs don't have the <code>WRKBUILD/WRKSRC</code> distinction.
Programs based on autoconf (mostly) can usually set <code>SEPARATE_BUILD</code>
to let the port build happen in a <code>WRKBUILD</code> distinct from
<code>WRKSRC</code>.</dd>

<dt><code>WRKCONF</code></dt>

<dd>Subdirectory of <code>WRKDIR</code> where configure scripts should be run.
Defaults to <code>WRKBUILD</code>, which is correct 99% of the time.</dd>

<dt><code>WRKINST</code></dt>

<dd>Directory where the port will be installed before being packaged (see
"faking ports" below).</dd>
</dl>

<p>
<i>Note that <code>NO_WRKSUBDIR</code> has been removed: its functionality can
be achieved by setting <code>WRKDIST=$(WRKDIR)</code> instead.</i>

<h2 id="Fake">Fake Port Installation</h2>

<h3 id="Introduction">Введение</h3>

After a build is complete, other BSDs proceed to install a port, then build
a package from the installed port.
OpenBSD uses faked installation instead.

<ul>
<li>An OpenBSD port is configured and built normally (e.g., to install under
<code>PREFIX</code>, usually <code>/usr/local</code>).

<li>But it's told to install elsewhere, namely under <code>WRKINST</code>, which
is usually a subdirectory of <code>WRKDIR</code>.

<li>Then the false installation is packaged, using the <code>-B</code> option of
pkg_create.

<li>Finally, the resulting package can be installed, using pkg_add.
</ul>

<h3 id="Advantages">Преимущества</h3>

<ul>
<li>For a package builder, it means that most ports don't have to actually be
installed, which removes a large number of potential compromises and general
nastiness from badly-installed ports.
It also allows building several conflicting packages on the same machine.
Finally, it allows building a new set of untested packages without hosing
a correct installation.

<li>For a port writer, it greatly simplifies the task of finding problems in
packing lists, since the fake area of installation is empty before the port
gets installed.
Also, if a port installs too many files, it is no longer necessary to tweak
the port installation: it is enough not to record the extraneous files in
the packing list.

<li>For the end user, it improves the quality of packages: since the final
port is installed using pkg_add, the end user gets <i>exactly</i> the same
software that was prepared on the porter's machine.
</ul>

<h3 id="How">Как это использовать</h3>

The targets invoked for <code><b>make fake</b></code> are the usual install
targets, except for a few differences:

<ul>
<li><code>FAKE_FLAGS</code> is used instead of <code>MAKE_FLAGS</code>.
By default, <code>FAKE_FLAGS</code> sets <code>DESTDIR=${WRKINST}</code>.

<li><code>FAKE_TARGET</code> is used instead of <code>INSTALL_TARGET</code>.

<li>The <code>{pre,do,post}-install</code> fragments are invoked with
<code>TRUEPREFIX</code> set to <code>$(PREFIX)</code>,
<code>PREFIX</code> set to <code>$(WRKINST)$(PREFIX)</code>, and
<code>DESTDIR</code> set to <code>$(WRKINST)</code>.
</ul>

<p>
Ports using imake should work as is, since the imake fragments are configured
to use <code>DESTDIR</code>.
Similarly, recent GNU configure ports should need no change.

<p>
Another good technique is a "late binding" trick: configure the ports to use
a prefix of <code>$(DESTDIR)/usr/local</code>, so that the resulting
<code>Makefile</code> has the following set:

<pre class="cmdbox">
prefix=$(DESTDIR)/usr/local
</pre>

When the port gets built, since <code>DESTDIR</code> is set to nothing,
<code>/usr/local</code> is used.
The fake install will put everything into <code>${WRKINST}/usr/local</code>
(e.g., for GNU configure, use <code>CONFIGURE_STYLE= gnu dest</code>).

<h3 id="Pitfalls">Ловушки</h3>

<ul>
<li>Some ports are inconsistent in their <code>DESTDIR</code> processing: most
of the port is happy with <code>DESTDIR</code> set, except for one or two
offenders.
Patch the problem away.

<li>Be careful to distinguish between the actual location where the port is
installed, and the location recorded in the configuration files of the package.
This is very easy to overlook, but easy to fix using <code>TRUEPREFIX</code>.

<li>Absolute symlinks always need to be tweaked.
Luckily, <code>bsd.port.mk</code> will notice problems in that area.

<li>A few ports don't want to leave <code>$(DESTDIR)</code> alone at the
configure stage.
A <code>post-configure</code> fragment that tweaks all Makefiles to add the
<code>DESTDIR</code> is needed.

<li>Very seldom, a port will resist all reasonable attempts to use FAKE.
A brute force approach should work: use <code>pre-fake</code> to link or copy
everything the port wants to find in the <code>WRKINST</code> area, then perform
the install under chroot.
</ul>

<h2 id="Tools">Packaging инструменты</h2>

Инструменты пакета знают о довольно многих типах файлов и могут делать многое
автоматически: в большинстве случаев команды <code>@exec</code> или скрипты
<code>INSTALL</code> не нужны.

<p>
Обратите внимание, что все ненужные скрипты должны быть заблокированы,
так как они имеют проблемы с масштабируемостью.
Гораздо проще отлаживать инфраструктуру одного пакета, чем модифицировать
сотни скриптов для решения новых проблем.
Например:

<ul>
<li><code>@exec ldconfig</code> не нужен, поскольку shared libraries упоминаются
    как <code>@lib libfoo.so.1.0</code>, а <code>ldconfig</code> запускается
    только при необходимости и корректно обрабатывает chroot.

<li><code>@exec install-info</code> не нужен, поскольку файлы документации info
    упоминаются как <code>@info file.info</code>. Благодаря этому нет проблем и
    с составными info файлами, а также отпадает необходимость в запуске
    <code><b>makeinfo --no-split</b></code>.

<li>шрифты (fonts) интегрируются автоматически благодаря
   <code>@font</code> и <code>@fontdir</code>.

<li>Новые пользователи и группы создаются при помощи <code>@newuser</code>
    и <code>@newgroup</code> вместо installation скриптов.
    Они создаются достаточно рано, чтобы их можно было использовать в процессе
    дальнейшего extraction пакета.

<li>Большинство third party баз данных обрабатываются при помощи <code>@tag</code>,
    который запускает такие инструменты как <code>update-desktop-database</code>
    в конце установки.

<li>Файлы конфигурации обрабатываются при помощи <code>@sample</code>
    вместо installation скриптов.
</ul>

<p>
Прочитайте <a href="https://man.openbsd.org/pkg_create">pkg_create(1)</a>, где
содержится более подробная информация по этой теме.
В большинстве случаев, <code><b>make update-plist</b></code> создаст очень хорошую
приблизительную картину того, что должно быть в packing-list и скопирует настройки
из одной версии в другую (следующую).


<h2 id="Flavors">Flavors</h2>

Параметры сборки были организованны (рационализированы) в виде Flavors, так
что сборка пакетов теперь может быть последовательной.
Порт с параметрами должен установить <code>FLAVORS</code> в качестве списка
всех параметров, которые имеют смысл для этого порта (например,
<code>FLAVORS=foo bar zoinx</code>), а затем использовать <code>FLAVOR</code>,
чтобы проверить, какие параметры фактически были выбраны (например,
<code>FLAVOR=zoinx foo</code>).
<code>bsd.port.mk</code> предоставляет тут некоторую поддержку:

<ul>
<li>The <code>PKGNAME</code> is tweaked to include dash separated options (e.g.,
<code>package-foo-zoinx</code>).

<li>The <code>WRKDIR</code> is tweaked so that distinct flavors can be built
concurrently without colliding.

<li>Constructs of the form <code>%%flavor%%</code> will trigger the inclusion of
<code>PFRAG.flavor</code>.

<li><code>bsd.port.subdir.mk</code> understands the extension
<code>SUBDIR=directory,opt1,opt2</code> to say
"build port in <code>directory</code> with <code>FLAVOR=opt1 opt2</code>."
</ul>

<p>
Проверить, что тот или иной flavor был выбран для сбоки, можно следующим образом:

<pre class="cmdbox">
.if ${FLAVOR:Mzoinx}
</pre>

Существует дополнительное расширение, известное как <code>MULTI_PACKAGES</code>.
Вообще говоря, <code>MULTI_PACKAGES</code> и <code>FLAVORS</code> являются
противоположными механизмами.
Вместе их количество в дереве портов OpenBSD несколько меньше, чем в другиех BSD,
поскольку они позволяют из одного порта создавать много разных пакетов.
<a href="https://man.openbsd.org/bsd.port.mk">bsd.port.mk(5)</a> имеет
<a href="https://man.openbsd.org/bsd.port.mk#FLAVORS_AND_MULTI_PACKAGES">целый раздел</a>,
посвященный FLAVORS и MULTI_PACKAGES.
